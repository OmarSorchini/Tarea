# Author: A01749389 Omar Rodrigo Sorchini Puente
from arpeggio import PTNodeVisitor


class CodeGenerationVisitor(PTNodeVisitor):

    WAT_TEMPLATE = ''';; Code generated by the Delta compiler
(module
  (func
    (export "_start")
    (result i32)
{}  )
)
'''

    def __init__(self, symbol_table, **kwargs):
        super().__init__(**kwargs)
        self.__symbol_table = symbol_table

    def visit_program(self, node, children):

        def declare_variables():
            return ''.join([f'    (local ${var_name} i32)\n'
                            for var_name in self.__symbol_table])

        print(CodeGenerationVisitor.WAT_TEMPLATE.format(
            declare_variables()
            + ''.join(children)))

        return CodeGenerationVisitor.WAT_TEMPLATE.format(
            declare_variables()
            + ''.join(children))

    def visit_statement(self, node, children):
        return children[0]

    def visit_declaration(self, node, children):
        return ''

    def visit_assignment(self, node, children):
        return children[1] + children[0]

    def visit_lhs_variable(self, node, children):
        return f'    local.set ${node.value}\n'

    def visit_if(self, node, children):
        endsCount = 1
        result = (children[0]
                  + '    if\n'
                  + children[1])
        
        if len(children) == 3:
            result += ('    else\n'
                       + children[2])
        else:
            pairs = 0
            for i in range(len(children[2:])):
                if pairs % 2 == 0:
                    result += ('    else\n'
                           + children[i+2])
                else:
                    endsCount += 1
                    result += ('    if\n'
                           + children[i+2])
                pairs += 1

        result += '    end\n'* endsCount
        #print(result)
        return result

    def visit_block(self, node, children):
        return ''.join(children)
    
    def visit_do(self, node, children):
        return ('    loop\n'
                + children[0]
                + children[1]
                + '    br_if 0\n'
                + '    end\n')

    def visit_while(self, node, children):
        return ('    block\n'
                + '    loop\n'
                + children[0]
                + '    i32.eqz\n'
                + '    br_if 1\n'
                + children[1]
                + '    br 0\n'
                + '    end\n'
                + '    end\n')

    def visit_expression(self, node, children):
        if len(children) == 1:
            return children[0]
        
        result = []

        for exp in children[:-1]:
            result.append(exp)
            result.append('    if (result i32)\n')
            result.append('    i32.const 1\n')
            result.append(f'    else\n')

        result.append(children[-1])
        result.append('    i32.eqz\n'*2)
        result.append('    end\n' * len(children[:-1]))
        
        return ''.join(result)
    
    def visit_and(self, node, children):
        if len(children) == 1:
            return children[0]
        result = [children[0]]
        for exp in children[1:]:
            result.append('    if (result i32)\n')
            result.append(exp)
        result.append('    i32.eqz\n' * 2)
        result.append('    else\n'
                      '    i32.const 0\n'
                      '    end\n' * (len(children) - 1))
        return ''.join(result)
    
    def visit_comparison(self, node, children):
        result = [children[0]]
        for i in range(1, len(children), 2):
            result.append(children[i + 1])
            match children[i]:
                case '==':
                    result.append('    i32.eq\n')
                case '!=':
                    result.append('    i32.ne\n')
                case '>=':
                    result.append('    i32.ge_u\n')
                case '>':
                    result.append('    i32.gt_u\n')
                case '<=':
                    result.append('    i32.le_u\n')
                case '<':
                    result.append('    i32.lt_u\n')
        return ''.join(result)

    def visit_additive(self, node, children):
        result = [children[0]]
        for i in range(1, len(children), 2):
            result.append(children[i + 1])
            match children[i]:
                case '+':
                    result.append('    i32.add\n')
                case '-':
                    result.append('    i32.sub\n')
        return ''.join(result)

    def visit_multiplicative(self, node, children):
        result = [children[0]]
        for i in range(1, len(children), 2):
            result.append(children[i + 1])
            match children[i]:
                case '*':
                    result.append('    i32.mul\n')
                case '/':
                    result.append('    i32.div_s\n')
                case '%':
                    result.append('    i32.rem_s\n')
        return ''.join(result)

    def visit_unary(self, node, children):
        result = children[-1]
        for op in children[-2::-1]:
            match op:
                case '+':
                    ...  # do nothing
                case '-':
                    result = (
                        '    i32.const 0\n'
                        + result
                        + '    i32.sub\n'
                    )
                case '!':
                    result += '    i32.eqz\n'
        return result

    def visit_primary(self, node, children):
        return children[0]

    def visit_binary(self, node, children):
        value = node.value[2:]
        value = value[::-1]
        decVal = 0
        for i in range(len(value)):
            if int(value[i]) == 1:
                decVal += 2**i
        return f'    i32.const {decVal}\n'

    def visit_octal(self, node, children):
        value = node.value[2:]
        value = value[::-1]
        decVal = 0
        for i in range(len(value)):
            decVal += (8 ** i) * int(value[i])
        return f'    i32.const {decVal}\n'

    def visit_hexa(self, node, children):
        value = node.value[2:]
        value = value[::-1]
        decVal = 0
        for i in range(len(value)):
            if value[i].isdigit():
                decVal += (16 ** i) * int(value[i])
            elif (value[i].lower() in "abcdef"):
                letter = value[i].lower()
                if letter == "a":
                    decVal += (16 ** i) * 10
                elif letter == "b":
                    decVal += (16 ** i) * 11
                elif letter == "c":
                    decVal += (16 ** i) * 12
                elif letter == "d":
                    decVal += (16 ** i) * 13
                elif letter == "e":
                    decVal += (16 ** i) * 14
                elif letter == "f":
                    decVal += (16 ** i) * 15

        return f'    i32.const {decVal}\n'

    def visit_decimal(self, node, children):
        return f'    i32.const {node.value}\n'

    def visit_boolean(self, node, children):
        if children[0] == 'true':
            return '    i32.const 1\n'
        else:
            return '    i32.const 0\n'

    def visit_parenthesis(self, node, children):
        return children[0]

    def visit_rhs_variable(self, node, children):
        return f'    local.get ${node.value}\n'
